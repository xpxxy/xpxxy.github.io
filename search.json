[{"title":"随手记事","date":"2024-09-11T13:32:39.000Z","url":"/2024/09/11/notes/","tags":[["随笔记事","/tags/%E9%9A%8F%E7%AC%94%E8%AE%B0%E4%BA%8B/"],["git","/tags/git/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"iconfont库的使用方法iconfont库的基本使用方式： 1.在网站内选择好项目需要的icon包（点击那个购物车即可加入） 2.下载所需的包，导入项目内引入 3.修改包内的css文件,导入在项目下相对路径的位置的ttf格式字体文件 4.将iconfont.css引入至app.vue内 具体使用（vue2）： CSS文字密度控制如果有大段的文字，想控制文字在一定区域内显示，然后超出部分….省略可以用以下属性： box-sizing属性box-sizing 属性可以被用来调整这些表现： content-box 是默认值。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。 border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在 width 内的。也就是说，如果你将一个元素的 width 设为 100px，那么这 100px 会包含它的 border 和 padding，内容区的实际宽度是 width 减去 (border + padding) 的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。 border-box不包含margin！ padding &amp; margin请牢记 第一个参数上下，第二个左右 四个分开就是 上 右 下 左 在家里写完代码提交后在公司内拉取（一般不建议如此操作） git stash如果写到一半想换分支还保持写之前的状态？可以使用: **git stash ** Echarts基础使用方法echarts图表的绘制,大体分为三步: 根据 DOM实例，通过echarts.init方法，生成echarts 实例 构建options配置对象，整个echarts的样式，皆有该对象决定 最后通过实例.set0ption方法,设置配置对象 (可选)通过监听属性，动态刷新图表数据 "},{"title":"iconpark","date":"2024-09-11T13:07:37.000Z","url":"/2024/09/11/iconpark/","tags":[["iconpark","/tags/iconpark/"],["字体图标","/tags/%E5%AD%97%E4%BD%93%E5%9B%BE%E6%A0%87/"],["教程","/tags/%E6%95%99%E7%A8%8B/"]],"categories":[["教程","/categories/%E6%95%99%E7%A8%8B/"]],"content":"介绍iconPark 是字节跳动出品的一款字体图标icon库，和iconfont类似，但其中字节官方出品的icon会多一些，但也有民间制作丰富的各色生态图标库。 官方网站地址：iconPark地址 上述链接点进去后就可以根据UI的要求，直接选择具体想要的icon，配置好后可以一键复制代码； 安装使用官方提供了几种方式，一种是使用svg图标，一种是正常的组件引入 执行下面代码将安装vue2 版本的icon 在项目目录执行安装后会安装最新的版本，npm包体约10m，所以安装完后使用时不可能直接全局引入所有的图标直接使用，所以需要按需引入使用。 样式文件还是需要全局引入比较好，而且该包体的样式文件不大。 使用方式： "},{"title":"c++小细节","date":"2024-09-11T12:26:16.000Z","url":"/2024/09/11/c-%E5%B0%8F%E7%BB%86%E8%8A%82/","tags":[["C++","/tags/C/"]],"categories":[["学习","/categories/%E5%AD%A6%E4%B9%A0/"]],"content":"cpp小细节1. 简单的文件实例 2.有关static的事情static 关键字可用于在全局范围、命名空间范围和类范围声明变量和函数。 静态变量还可在本地范围声明。 静态持续时间意味着，在程序启动时分配对象或变量，并在程序结束时释放对象或变量。 外部链接意味着，变量的名称在用于声明变量的文件的外部是可见的。 相反，内部链接意味着，名称在用于声明变量的文件的外部是不可见的。 默认情况下，在全局命名空间中定义的对象或变量具有静态持续时间和外部链接。 在以下情况下，可使用 static 关键字。 在文件范围（全局和&#x2F;或命名空间范围）内声明变量或函数时，**static** 关键字将指定变量或函数具有内部链接。 在声明变量时，变量具有静态持续时间，并且除非您指定另一个值，否则编译器会将变量初始化为 0。 在函数中声明变量时，**static** 关键字将指定变量将在对该函数的调用中保持其状态。 在类声明中声明数据成员时，**static** 关键字将指定类的所有实例共享该成员的一个副本。 必须在文件范围内定义 static 数据成员。 声明为 const static 的整型数据成员可以有初始化表达式。 在类声明中声明成员函数时，**static** 关键字将指定类的所有实例共享该函数。 由于函数没有隐式 this 指针，因此 static 成员函数不能访问实例成员。 若要访问实例成员，请使用作为实例指针或引用的参数来声明函数。 不能将 union 的成员声明为 **static**。 但是，全局声明的匿名 union 必须是显式声明的 **static**。 详情查看Microsoft Docs static关键字 3.std::endl“\\n” 表示内容为一个回车符的字符串。std::endl 是流操作，输出的作用和输出 “\\n” 类似，但可能略有区别。std::endl 输出一个换行符，并立即刷新缓冲区。 例如 其相当于： 或者 由于流操作符 &lt;&lt; 的重载，对于 ‘\\n’ 和 “\\n”，输出效果相同。对于有输出缓冲的流（例如cout、clog），如果不手动进行缓冲区刷新操作，将在缓冲区满后自动刷新输出。不过对于 cout 来说（相对于文件输出流等），缓冲一般体现得并不明显。但是必要情况下使用 endl 代替 ‘\\n’ 一般是个好习惯。对于无缓冲的流（例如标准错误输出流cerr），刷新是不必要的，可以直接使用 ‘\\n’。 关于fflush: 参考解释1参考解释2 不过在没有必要刷新输出流的时候应尽量使用 cout &lt;&lt; ‘\\n’, 过多的 endl 是影响程序执行效率低下的因素之一。其实这样也可以解决很多的问题，比如用户输入错误啊之类的，这样不管别人怎么输入，前面的东西全都没了，不会影响后面的输入。注意，这里只是将缓冲区给清空了，不会对你的程序产生影响，除了时间上，反倒是在某种意义上来说提高了程序的容错性。 如果想显示多行文本，如下： 不用一直这样 cout 多行插入。真正的开发过程中， 尽量避免使用 using namespace std; 等直接引入整个命名空间，否则会因为命名空间污染导致很多不必要的问题， 比如自己写的某个函数，名称正好和 std 中的一样， 编译器会不知道使用哪一个， 引起编译报错， 建议使用: 等直接由命名空间组合起来的全称。"},{"title":"网站介绍","date":"2024-09-07T14:54:43.000Z","url":"/2024/09/07/%E7%BD%91%E7%AB%99%E4%BB%8B%E7%BB%8D/","tags":[["网站管理","/tags/%E7%BD%91%E7%AB%99%E7%AE%A1%E7%90%86/"],["基础介绍","/tags/%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"]],"categories":[["undefined",""]],"content":"本网站是本人的简单博客，里面写的内容全是放屁，请勿当真，如有雷同，纯属放屁。"}]